# get stdlib modules
from pathlib import Path

# get local modules
from utils.utils_qc import QCUtils
from utils.utils_pipeline import PipelineUtils

# define data flow directories
work_dir: Path = Path(config["work_dir"])
input_dir: Path = Path(config["pipeline_input"])
output_dir: Path = Path(f'{input_dir}/{config["results"]}/{config["output_dir"]}')

# define log & benchmark directories
log_dir: Path = Path(f'{output_dir}/{config["log_dir"]}')
benchmarks_dir: Path = Path(f'{output_dir}/{config["benchmarks_dir"]}')

# generate flattened samples list
flattended_samples: list = []
flattended_samples.extend(config["sample_groups"]["control"])
flattended_samples.extend(config["sample_groups"]["condition"])

# get available resources
memory: float = PipelineUtils.get_available_memory()
cores: int = PipelineUtils.get_max_cores()

# generate a list of all files to be generated by rule `all` (terminal files)
terminal_files: list = QCUtils.generate_terminal_files(
    out_dir=output_dir,
    flattened_sample_list=flattended_samples,
    sample_type=config["sample_type"],
)


rule all:
    """
    Generate all terminal files for the snakemake rule(s) below
    """
    input:
        terminal_files,
    output:
        temp(touch(f"{work_dir}/progress/qc.done")),


rule run_fastp_pe:
    """
    Runs Fastp for paired-end seq to remove low
    quality reads, adapters and polyG tails &
    detects adapters
    """
    input:
        fastq_R1=input_dir / "{sample}_R1.fastq.gz",
        fastq_R2=input_dir / "{sample}_R2.fastq.gz",
    output:
        trimmed_fastq_R1=output_dir / "{sample}_R1.trimmed.fastq.gz",
        trimmed_fastq_R2=output_dir / "{sample}_R2.trimmed.fastq.gz",
        html=output_dir / "{sample}.html",
        json=output_dir / "{sample}.json",
    params:
        length=50,
    priority: 1
    conda:
        "../envs/env_qc.yaml"
    message:
        "Running Fastp for sample {wildcards.sample}"
    log:
        log_dir / "{sample}_qc.log",
    benchmark:
        benchmarks_dir / "{sample}_qc.benchmark.txt"
    threads: cores * 2
    resources:
        mem_gb=memory,
    shell:
        """
        fastp \
        --in1 {input.fastq_R1} \
        --in2 {input.fastq_R2} \
        --out1 {output.trimmed_fastq_R1} \
        --out2 {output.trimmed_fastq_R2} \
        --length_required {params.length} \
        --thread {threads} \
        --html {output.html} \
        --json {output.json} \
        --report_title "{wildcards.sample} fastp report" \
        &> {log}
        """


rule run_fastp_se:
    """
    Runs Fastp for single-end seq to remove low
    quality reads, adapters and polyG tails &
    detects adapters
    """
    input:
        fastq=input_dir / "{sample}.fastq.gz",
    output:
        trimmed_fastq=output_dir / "{sample}.trimmed.fastq.gz",
        html=output_dir / "{sample}.html",
        json=output_dir / "{sample}.json",
    wildcard_constraints:
        sample="\d+"
    params:
        length=50,
    priority: 1
    conda:
        "../envs/env_qc.yaml"
    message:
        "Running Fastp for sample {wildcards.sample}"
    log:
        log_dir / "{sample}_qc.log",
    benchmark:
        benchmarks_dir / "{sample}_qc.benchmark.txt"
    threads: cores * 2
    resources:
        mem_gb=memory,
    shell:
        """
        fastp \
        --in1 {input.fastq} \
        --out1 {output.trimmed_fastq} \
        --length_required {params.length} \
        --thread {threads} \
        --html {output.html} \
        --json {output.json} \
        --report_title "{wildcards.sample} fastp report" \
        &> {log}
        """
